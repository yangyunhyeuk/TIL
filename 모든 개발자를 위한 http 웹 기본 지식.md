

# IP

IP : 인터넷 프로토콜 역할

- 지정한 ip 주소에 데이터 전달
- 패킷이라는 통신 단위로 데이터 전달

ip 프로토콜

출발지 ip 주소, 도착지 ip 주소가 담긴 패킷을 서버에 전송하여 전달된다. 

ip 프로토콜의 한계

- 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- 비신뢰성 : 중간에 패킷이 소실되거나, 패킷 순서가 꼬이는 경우 발생
- 프로그램 구분 : 같은 ip를 사용하는 서버에서 통신하는 어플이 2개 이상이라면

패킷은 노드를 타고 이동하기에 최종적으로 나중에 보낸 패킷이 먼저 도착할 수 있다. 

 

---

# TCP

전송 제어 프로토콜(Transmission Control Protocol)

- 연결 지향 - TCP 3 way handshake (가상 연결)
- 데이터 전달 보증 (데이터가 누락될 시 알 수 있다)
- 순서를 보장해준다.

- 신뢰할 수 있는 프로토콜로 현재 대부분 TCP를 사용한다.

TCP 3 way handshake (가상 연결)란 클라이언트와 서버에 신뢰가 생긴다

1. SYN  : 특정 IP를 갖는 클라이언트가 다른 IP를 갖는 서버에 접속을 요청한다. 

2. SYN+ACK : 서버는 해당 요청에 대해 수락한 뒤 접속 요청을 날린다. 

3. ACK : 그러면 요청이 수락되어 연결되고 나면 데이터를 전송하는 것이다. 

위에서 가상 연결이라 쓰인 이유는 실제로 연결이 된 게 아니라 중간에 수많은 서버를 거쳐 진행되기에 개념적으로 가상 연결이라는 단어가 쓰인 것이다. 

TCP 패킷 안에는 전송 제어, 순서, 검증 정보, 출발지 PORT, 도착지 PORT 정보가 담겨있고

그걸 감싼 IP 패킷에는 출발지 IP, 목적지 IP를 담고 있다. 

---

 

# UDP

- 사용자 데이터그램 프로토콜(User Datagram Protocol)의 약자로
    
    IP와 거의 같으며, PORT와 체크섬(해당 메시지가 맞는지 검증해주는 데이터) 정도만 추가되었다.
    
    TCP는 다 좋은데 3 WAY HANDSHAKE를 하려면 처리 속도가 오래 걸리는 단점이 있다. 
    
    그래서 UDP는 애플리케이션에서 추가 작업하여 사용할 수 있다.  
    

---

 

통상적으로 이해하기 쉽게 TCP/IP 패킷에는 

출발지 IP, PORT, 도착지 IP, PORT, 전송 데이터를 담고 있다. 

# PORT

- 같은 IP 내에서 프로세스를 구분하는 역할을 한다.

- IP가 아파트라면 PORT는 몇동 몇호를 의미한다.

---

# DNS

- IP는 변경될 수 있고 기억하기 힘든데, DNS가 이를 해결해준다.
- 네이버의 DNS는 naver.com

---

IP : 인터넷 망에서 메시지를 보내기 위해 존재하는 프로토콜

TCP : 메시지 순서등 신뢰성을 높여준다. 

UDP : IP랑 같으나 포트 넘버만 추가된다. 어플리케이션을 통해 기능 확장 가능

PORT : 같은 IP 내에서 동작할 어플리케이션을 구분하기 위한 것이다.  

DNS : 도메인 명을 등록하여 사용하는 것으로 기억하기 힘든 IP를 대체해준다. 

---

URI : Resource Identifier 로케이터, 이름 또는 둘다 추가로 분류될 수 있다. 

URL : Resource Locater 자원을 위치로 

URN : Resource Name 자원을 이름으로

---

http : HyperText Tranfer Protocol은 거의 모든 형태의 데이터 전송이 가능하고 서버 간 데이터를 주고 받을 때도 사용한다. 

---

# stateful : 중간에 다른 점원으로 바뀌면 안된다(상태 유지) 이는 상태를 보관하고 있어 서버에 장애가 생기면 장애가 발생한다.

# stateless : 중간에 점원이 바뀌어도 된다(무상태) 이는 아무 서버나 호출해도 상태를 보관하지 않아 장애가 발생하지 않는다

# http 헤더 : http 전송에 필요한 모든 부가정보를 담고 있다. (메시지 바디 내용, 메시지 바디 크기, 압축, 인증, 요청 클라이언트 정보)

# http 바디 : 실제 전송할 데이터를 담고 있으며 byte로 표현할 수 있는 html 문서, 이미지, 영상, json 등 모든 데이터 전송이 가능하다.

## http 정리

1. http 메시지에 모든 것을 전송한다. 
2. 단순하고 확장이 가능하다. 
3. 무상태 프로토콜

### get

1. 리소스 조회
2. 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
3. 메시지 바디를 사용해서 데이터를 전달할 수 있지만 지원하지 않는 곳이 많아 비권장

### post

1. 새 리소스 생성(등록)
    1. 서버가 아직 식별하지 않은 새 리소스 생성
2. 요청 데이터 처리
    1. 단순히 데이터를 생성하거나 변경하는 것을 넘어 프로세스를 처리하는 경우
        1. 주문에서 결제완료 → 배달시작 → 배달완료 처럼 단순히 값 변경을 넘어 프로세스 상태가 변하는 경우
        2. POST의 결과로 새로운 리소스가 생성되지 않을 수도 있다.
3. 다른 메서드로 처리하기 애매한 경우
    1. JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우
    2. 애매하면 POST를 쓴다.

### put

1. 리소스를 대체
    1. 리소스가 있으면 대체, 기존의 것을 없애고 덮는 의미이다. 
    2. 없으면 새로 생성으로 갈아치운다는 특징이다.
    3. 쉽게 말해 덮어버린다는 얘기이다.
2. 클라이언트가 리소스를 식별
    1. 클라이언트가 리소스 위치를 알고 uri를 지정한다.
    2. 위의 특징이 post와의 차이점이다. 

### fetch

1. 리소스 부분 변경

### delete

1. 리소스 삭제

### http 메서드의 속성

1. 안전 : 호출해도 리소스가 변경되지 않는다. get외에 post, put, delete는 안전하지 않다.
    1. get를 계속 호출하여 로그가 쌓여서 장애가 발생하는 경우는 제외하고 해당 리소스만 취급
2. 멱등
    1. 한 번 호출하든 두 번 호출하든 결과가 똑같다. 
        1. get : 한 번 조회하든 두 번 조회하든 같은 결과다. 
        2. put : 같은 요청을 여러 번 해도 매번 갈아끼우니 결과는 같다. 
        3. delete : 같은 삭제 요청을 여러 번 해도 결과는 같다. 
        4. post의 경우 중복 데이터 발생 우려가 있어 멱등성에 해당하지 않는다. 
    2. 멱등은 중간에 요청이 들어와 데이터 변동이 발생하여 결과가 바뀌는 상황까지 고려하지 않는다. 
3. 캐시 가능
    1. 응답 결과 리소스를 캐시해서 사용해도 되는가
        1. get, head, post, patch 캐시 가능
        2. 실제로는 get, head 정도만 캐시로 사용한다. 

---

클라이언트에서 서버로 데이터 전송하는 경우

데이터 전달 방식은 크게 2가지이다. 

1. 쿼리 파라미터를 통한 데이터 전송
    1. get
    2. 검색어 정렬 필터가 그 예이다.
2. 메시지 바디를 통한 데이터 전송
    1. post, put, patch
    2. 회원가입, 상품 주문, 리소스 등록, 리소스 변경이 그 예이다. 

4가지의 상황

1. 정적 데이터 조회
    1. 이미지, 정적 텍스트 문서 : get으로 resource/path만 적어주면 된다.
2. 동적 데이터 조회
    1. 주로 검색, 게시판 목록에서 정렬 필터 : 동적으로 조회하기 위해 url path에 쿼리값도 같이 넘긴다.
3. html Form을 통한 데이터 전송
    1. 회원가입, 상품 주문, 데이터 변경 
4. http API를 통한 데이터 전송 
    1. 회원가입, 상품 주문, 데이터 변경 : form을 통한 통신이 아닌 그 외의 데이터 전송을 의미한다. 대표적인 예로 ajax가 있다. 
    2. 서버 to 서버, 앱 클라이언트, 웹 클라이언트(ajax)

---

  

HTML Form의 경우 get, post 방식만을 지원하기에 

추가적으로 컨트롤 uri라는 방법을 사용해야 한다. 

- get, post 방식만 지원하기에 제약이 발생한다.
- 해당 제약을 해결하기 위해 동사로 된 리소스 경로를 사용한다.
- post의 /new, /edit, /delete가 컨트롤 uri이다.
- 이는 http 메서드로 해결하기 애매할 때 사용한다.

---

4가지의 API 설계 개념

1. 문서(document) 
    - 단일 개념으로 파일 하나, 객체 인스턴스, 데이터베이스 row가 해당한다.
    - ex) /members/100, /files/star.jpg
2. 컬렉션(collection) 
    - 서버가 관리하는 리소스 디렉터리
    - 서버가 리소스의 URI를 생성하고 관리
    - ex) /members
3. 스토어(store)
    - 클라이언트가 관리하는 자원 저장소
    - 클라이언트가 리소스의 URI를 알고 관리한다.
    - ex) /files
4. 컨트롤러(Controller), 컨트롤 URI
    - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
    - 동사를 직접 사용
    - ex) /members/{id}/delete
    

---

### HTTP 상태 코드

- 1XX(Informational) : 요청이 수신되어 처리 중이다.
- 2XX(Successful) : 요청이 정상 처리되었다.
    - 200 : ok 해당 요청 리소스가 정상적으로 처리되는 경우에 해당된다.
    - 201 : created 요청에 성공하여 새로운 리소스가 생성된다.
    - 202 : Accepted 요청이 접수는 되었으나 처리가 완료되지 않은 것으로 배치 처리 같은 곳에서 사용한다.
    - 204 No Content 서버가 요청을 성공적으로 수행했으나, 응답 페이로드 본문에 보낼 데이터가 없는 경우에 해당한다. 예를 들어 웹 문서에 편집기에서 저장 버튼을 누를 시 그에 대한 결과로 아무 내용이 없어도 되는 경우, 버튼을 눌러도 같은 화면을 유지해야 하는 경우가 이에 해당된다.
- 3XX(Redirection) : 요청을 완료하려면 추가 행동이 필요하다.
- 4XX(Client Error) : 클라이언트 오류 발생, 잘못된 문법으로 서버가 요청을 수행할 수 없다.
- 5XX(Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못한다.

### 리다이렉션

- 웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면 Location 위치로 자동 이동된다.

1. 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동
    1. 원래의 url을 사용하지 않는다. 검색 엔진 등에서도 변경을 인지한다. 
    2. 301 Moved Permanently : 리다이렉트시에 http 내부 로직에 따라 요청 메서드가 get으로 변하고 본문이 제거될 수 있다. 
    3. 308 Permanent Redirect : 301과 기능은 같으나, 리다이렉트시 요청 메서드와 본문 유지
2. 일시 리다이렉션 : 일시적인 변경
    1. 주문 완료 후에 주문 내역 화면으로 이동
    2. PRG : Post/Redirect/Get
3. 특수 리다이렉션 : 결과 대신 캐시를 사용한다. 
